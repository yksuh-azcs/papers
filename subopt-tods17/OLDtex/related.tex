\section{Related Work}\label{sec:related}

\todo{Rick has modify token}

SQL has emerged as the {\em de facto} and {\em de jure} standard relational
database query and update language. It emerged as an ANSI and ISO standard
in 1986--7, with a major extension and refinement as SQL-92~\cite{Melton93} 
and an even larger extension as SQL:1999~\cite{Melton03} and refinement as
SQL:2008~\cite{SQL2008}. 

Query evaluation 
proceeds in several steps~\cite{Ramakrishnan03}. First, the SQL query is 
translated into alternative query evaluation plans based on the 
relational algebra via {\em query enumeration}. The cost
of each plan is then estimated and the plan with the lowest estimated cost
is chosen. These steps comprise query optimization, specifically {\em
cost-based query optimization}~\cite{Selinger}. The selected query plan is
then evaluated by the query execution engine which implements a set of
physical operators, often several for each logical operator such as
join~\cite{Graefe93}.

There has been extensive work in query optimization over the last 35
years. An influential survey~\cite{Chaudhuri98} does a superb job of
capturing the major themes that have pursued in the hundreds of articles
published on this general topic. Chaudhuri reviews the many techniques and
approaches that have been developed to represent the query plans, to
enumerate equivalent query plans, to handle some of the more complex lexical
constructs of SQL, to statistically summarize the base data, and to compute the
cost of evaluation plans. He also mentions some of the theoretical work
(which is much less prevalent) to understand the computational complexity of
these algorithms. Most of this work may be classified as adopting an
engineering perspective: how can we architect a query optimizer ``where 
(1)~the search space includes plans that have {\em low cost} (2)~the costing
technique is {\em accurate} (3)~the enumeration algorithm is {\em
  efficient}. Each of these three tasks is nontrivial and that is why
building a good optimizer is an enormous undertaking.'' \cite[page~35]{Chaudhuri98}

To determine the best query access plan, the cost model estimates the
execution time of each plan. There is a vibrant literature on this
subject~\hbox{\cite{Ioannidis03,Mannino88}}, including proposals for
histograms, sampling, and parametric methods. Again, these papers almost
always are engineering studies, providing new techniques that improve on the
state-of-the-art through increased accuracy or performance. There have also
been a few mathematical results, such as ``the task of estimating distinct
values is {\em provably} error prone, i.e., for any estimation scheme, there
exists a database where the error is significant''~\cite{Chaudhuri98}.

An optimizer for a language like SQL must content with a huge search space of
complex queries. Its first objective must be {\em correctness}: that the
resulting query evaluation plan produce the correct result for the
query. A secondary but clearly very important objective is {\em efficiency}; after
all, that is the raison d'etre for this phase. As is well known, the name
for this phase is an exaggeration, as existing optimizers do not produce
provably optimal plans. That said, the
query optimizers of prominent DBMSes generally do a superb job of producing
the best query evaluation plan for most queries. This performance is the
result of a fruitful collaboration between the research community and
developers.

However, even with great effort over decades, optimizers as a general class
are still poorly understood. As has been observed, ``query optimization has
acquired the dubious reputation of being something of a black
art''~\cite{Babcock05}. DeWitt has gone farther, stating that ``query
optimizers [do] a terrible job of producing reliable, good plans [for
  complex queries] without a lot of hand
tuning''~\cite[page~59]{winslett02}. And as we'll see, suboptimality is
possible even when considering only simple queries.
