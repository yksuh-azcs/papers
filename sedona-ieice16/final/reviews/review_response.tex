\documentclass[10pt,letterpaper]{article}

\usepackage{graphicx}
\usepackage{longtable}
\usepackage{algorithmic}
\usepackage{alltt}
\usepackage{array}
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
%\usepackage[caption=false]{caption}
\usepackage[dvipsnames]{color}
%\usepackage{colortbl}
%\usepackage{enumitem}
%\usepackage{eqparbox}
%\usepackage{fixltx2e}
%\usepackage{float}
%\usepackage{floatflt}
%\usepackage{mdwmath}
%\usepackage{mdwtab}
%\usepackage{multirow}
\usepackage{stfloats}
%\usepackage[font=footnotesize]{subfig}
\usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
%\usepackage[tight,normalsize,sf,SF]{subfigure}
%\usepackage{subfigure} 
\usepackage{times}
\usepackage{url}
\usepackage{verbatim} 
\usepackage{wrapfig}
\usepackage{xspace}
\usepackage{color}

\definecolor{grey}{RGB}{200,200,200}
\newcommand{\hilite}[1]{\colorbox{yellow}{#1}}
\newcommand{\hiliting}[1]{\colorbox{grey}{#1}}
\long\def\todo#1{\hilite{{\bf TODO:} {\em #1}}}

\setlength{\oddsidemargin}{0in}
\setlength{\textwidth}{6.5in}


% new commands: from file -- to permit re-use
%\input{newcommands.tex}

%Hyphenation problems
\hyphenation{name-space}
\hyphenation{schema-location}
\hyphenation{xml-lint}
\hyphenation{time-stamp}
\hyphenation{time-stamps}
\hyphenation{time-stamped}


\urlstyle{rm}
\graphicspath{{./figures/}}

\definecolor{gray}{rgb}{0.5,0.5,0.5}
%\newcommand{\rev}[1]{\textcolor{blue}{#1}}
%\newcommand{\quo}[1]{\textcolor{gray}{#1}}
%\newcommand{\rev}[1]{\vspace{3mm} \noindent {\em {\color{blue}{#1}}}}


\newenvironment{myindentpar}[1]%
{\begin{list}{}
         {\vspace{10pt}
					\setlength{\leftmargin}{#1}}
          \item[]
}
{\end{list}}
\newcommand{\rev}[1]{\begin{myindentpar}{.25in} {\em {\color{blue}{#1}}}\end{myindentpar}}

\newenvironment{myindentparQ}[1]%
{\begin{list}{}
         {\setlength{\leftmargin}{#1}}
          \item[]
}
{\end{list}}
\newcommand{\quo}[1]{\begin{myindentparQ}{.25in} {{\color{gray}{#1}}}\end{myindentparQ}}

\begin{document}

\title{Author's Reply}
\author{}
\maketitle

\section*{Overview}\label{sec:overview}
I appreciate your review and address your remaining question below. 
Note that my response to your question is 
incorporated into the revision and marked in {\color{blue}blue}.

\newcounter{RP}

\clearpage
\section*{Reviewer}\label{sec:rev1}

% 1
\rev{
$<<$ Reviewer's comments to the author(s) $>>$

The manuscript is well revised.

However, I have a question how to estimate each daemon's influence as time.
The estimation is important for accuracy of your proposed method.

For acceptance, please clarify the estimation method and its validity.

}

If I understand your question right, 
we actually *measure* each daemon's process time (PT) for each timing (sample) of a program-under-test, 
rather than estimate the influence of that daemon as time. 
Remind that PT is computed based on the measures of user and system time received from the kernel via 
the Netlink socket. To check whether the influence (in your terminology) was significant on each sample, 
we came up with an idea of the {\em cutoff} method by 
which we could eliminate a certain sample containing a daemon that ran over the respective cutoff time. 

To determine the cutoff associated with each daemon, we first identify infrequent, long-running daemons (\hbox{Steps~2---8}). 
We then compute the cutoff of each so-identified daemon (Step~9). 
The detailed cutoff computation is specified in the second paragraph in the right column on page~3. 
The final cutoff data that we obtained for our identified daemon are exhibited in Table~1. 
For more details about the identification and cutoff calculation, please revisit the blue text in Section~2. 

We applied the table to discard a sample involving 
a daemon whose PT is above the respective cutoff. Dropping a certain sample means that there happened such a daemon's significant influence on that sample. 
This indicates that we can't trust and include that sample in the base data to calculate the execution time of the given program. 

The validity of our protocol using the cutoff was assessed on real-world programs (sort and matrix multiplication) and the SPEC CPU2006 benchmark. 
As shown in Figure~5 and Table~3, our protocol obtained better measurement quality 
for those real workloads, compared with that of the existing timing scheme using elapsed time.  

For better clarification (to resolve your question), I slightly modified the Contribution paragraph, 
provided a single-line comment about the cutoff computation, and finally 
added the last sentence in parentheses in the prose of Step~9. 
These changes are marked in green. (Due to a space limit, more text could not be inserted.)

I hope my response to your concern resolved your question. But if I misunderstood you, please kindly let me know. I will re-address. 

\end{document}
