\documentclass[10pt,letterpaper]{article}

\usepackage{graphicx}
\usepackage{longtable}
\usepackage{algorithmic}
\usepackage{alltt}
\usepackage{array}
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
%\usepackage[caption=false]{caption}
\usepackage[dvipsnames]{color}
%\usepackage{colortbl}
%\usepackage{enumitem}
%\usepackage{eqparbox}
%\usepackage{fixltx2e}
%\usepackage{float}
%\usepackage{floatflt}
%\usepackage{mdwmath}
%\usepackage{mdwtab}
%\usepackage{multirow}
\usepackage{stfloats}
%\usepackage[font=footnotesize]{subfig}
\usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
%\usepackage[tight,normalsize,sf,SF]{subfigure}
%\usepackage{subfigure} 
\usepackage{times}
\usepackage{url}
\usepackage{verbatim} 
\usepackage{wrapfig}
\usepackage{xspace}
\usepackage{color}

\definecolor{grey}{RGB}{200,200,200}
\newcommand{\hilite}[1]{\colorbox{yellow}{#1}}
\newcommand{\hiliting}[1]{\colorbox{grey}{#1}}
\long\def\todo#1{\hilite{{\bf TODO:} {\em #1}}}

\setlength{\oddsidemargin}{0in}
\setlength{\textwidth}{6.5in}


% new commands: from file -- to permit re-use
%\input{newcommands.tex}

%Hyphenation problems
\hyphenation{name-space}
\hyphenation{schema-location}
\hyphenation{xml-lint}
\hyphenation{time-stamp}
\hyphenation{time-stamps}
\hyphenation{time-stamped}


\urlstyle{rm}
\graphicspath{{./figures/}}

\definecolor{gray}{rgb}{0.5,0.5,0.5}
%\newcommand{\rev}[1]{\textcolor{blue}{#1}}
%\newcommand{\quo}[1]{\textcolor{gray}{#1}}
%\newcommand{\rev}[1]{\vspace{3mm} \noindent {\em {\color{blue}{#1}}}}


\newenvironment{myindentpar}[1]%
{\begin{list}{}
         {\vspace{10pt}
					\setlength{\leftmargin}{#1}}
          \item[]
}
{\end{list}}
\newcommand{\rev}[1]{\begin{myindentpar}{.25in} {\em {\color{blue}{#1}}}\end{myindentpar}}

\newenvironment{myindentparQ}[1]%
{\begin{list}{}
         {\setlength{\leftmargin}{#1}}
          \item[]
}
{\end{list}}
\newcommand{\quo}[1]{\begin{myindentparQ}{.25in} {{\color{gray}{#1}}}\end{myindentparQ}}

\begin{document}

\title{Author's Reply}
\author{}
\maketitle

\section*{Overview}\label{sec:overview}
I appreciate your review and address the last question below. 
Note that I mark all the changes made to this revision to respond to your concern are marked in {\color{blue}blue}. 
I hope that these changes helped you better read the flow of the paper. 


\newcounter{RP}

\clearpage
\section*{Reviewer}\label{sec:rev1}

% 1
\rev{
$<<$ Reviewer's comments to the author(s) $>>$

The manuscript is well revised.

However, I have a question how to estimate each daemon's influence as time.
The estimation is important for accuracy of your proposed method.

For acceptance, please clarify the estimation method and its validity.

}

If I understood your question right, 
each daemon's influence is translated to its respective cutoff, which I proposed and derived in this paper. 
For the detailed cutoffs, please refer to Tab.~1 and for computation process (estimation method in your term), the second paragraph in the right column on page~3.
As mentioned in the paper, the cutoffs are used to drop any execution (sample) involving daemon executions 
over their respective cutoffs. This drop indicates that such an execution was *significantly influenced* by infrequent, long-running daemons and thus we cannot include 
that execution in the computation of the execution time of a given program.

To assess the validity of my protocol using the cutoffs, I used the SPEC CPU2006 benchmark suite and observed that the protocol 
outperformed the extant method using elapsed time, as exhibited in Tab.~3 on page~4 (as already indicated by the previous revision). 
Note also that I took out Fig.~1 and instead moved Fig.~5 in the former revision (now Fig.~1) upfront (on page~1) in this revision, 
to early draw the attention of the protocol's effectiveness on two real programs (insertion sort and matrix multiplication) with increasing workloads.

Last but not least, there seems a confusion from the used program-under-test (PUT) (e.g., PUT128 and PUT16384) 
for not only defining but also evaluating the protocol. (In fact, the PUT is also an arbitrary \hbox{compute-bound} program, 
so there's no problem with applying the protocol to that. But I acknowledge that the dual use of the PUT potentially confuses readers including you.)
To unravel the confusion, I have redesigned the protocol, divided into the three major steps, as shown in Fig.~2 on page~2. 
In the new design, I talk about the PUT, only in the context of protocol definition (Step~B), but do not use it for evaluation. 
As described above, the evaluation was performed on those two real-world programs and the SPEC CPU benchmarks.


%If I understand your question right, 
%we actually *measure* each daemon's process time (PT) for each timing (sample) of a program-under-test, 
%rather than estimate the influence of that daemon as time. 
%Remind that PT is computed based on the measures of user and system time received from the kernel via 
%the Netlink socket. To check whether the influence (in your terminology) was significant on each sample, 
%we came up with an idea of the {\em cutoff} method by 
%which we could eliminate a certain sample containing a daemon that ran over the respective cutoff time. 
%
%To determine the cutoff associated with each daemon, we first identify infrequent, long-running daemons (\hbox{Steps~2---8}). 
%We then compute the cutoff of each so-identified daemon (Step~9). 
%The detailed cutoff computation is specified in the second paragraph in the right column on page~3. 
%The final cutoff data that we obtained for our identified daemon are exhibited in Table~1. 
%For more details about the identification and cutoff calculation, please revisit the blue text in Section~2. 
%
%We applied the table to discard a sample involving 
%a daemon whose PT is above the respective cutoff. Dropping a certain sample means that there happened such a daemon's significant influence on that sample. 
%This indicates that we can't trust and include that sample in the base data to calculate the execution time of the given program. 
%
%The validity of our protocol using the cutoff was assessed on real-world programs (sort and matrix multiplication) and the SPEC CPU2006 benchmark. 
%As shown in Fig.~5 and Tab.~3, our protocol obtained better measurement quality 
%for those real workloads, compared with that of the existing timing scheme using elapsed time.  
%For more details, please refer to the blue text in Section~3.
%
%For better clarification, I slightly modified the Contribution paragraph, 
%provided a single-line comment about the cutoff computation, and finally 
%added the last sentence in parentheses in the prose of Step~9. 
%These changes are marked in blue and incorporated into the revision. 
%

If I'm misunderstood, please kindly let me know. I'll re-address. Many thanks for your great comments.

\end{document}
